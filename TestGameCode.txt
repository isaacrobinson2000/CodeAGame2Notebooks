%%javascript

class GameBlock extends GameCollisionObject {
    update(timeStep, gameState) {
        // Do we do anything in update?
        // No, because blocks don't move.
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [cx, cy, cw, ch] = camera.transformBox([this.x * this._blockSize , this.y * this._blockSize, this._blockSize, this._blockSize]);
                
        painter.fillStyle = "rgba(255, 0, 0, 0.5)";
        painter.fillRect(cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        
        painter.fillStyle = "red";
        painter.fillRect(cx, cy, cw, ch);
    }
}

class Player extends GameCollisionObject {
    constructor(x, y, blockSize, sprites) {
        super(x, y, blockSize, sprites);
        this._sprite = sprites.playerSprite.buildSprite();
        this._sprite.setAnimation("stand");
        this._inset = [8 / 32, 2 / 32, 16 / 32, 27 / 32];
        this._vx = 0; 
        this._vy = 0;
        this._ax = 0;
        this._ay = 0.09 / 1000;
        this._priorUp = false;
        this._numJumps = Infinity;
        this._fric_fac = 0.95;
        this._waitTime = 0;
        
        this._hp = 5;
        
        this._movable = true;
    }
    
    update(timeStep, gameState) {
        this._waitTime = Math.max(0, this._waitTime - timeStep);
        
        if(this._hp <= 0) {
            this._hp = 5;
            this._waitTime = 0;
            return true;
        }
        
        let keys = gameState.keysPressed;
        
        let anim = "stand"
        
        this._ax = 0;
        if("ArrowLeft" in keys) {
            this._ax -= 0.05 / 1000;
            anim = "run";
        }
        if("ArrowRight" in keys) {
            this._ax += 0.05 / 1000;
            anim = "run";
        }
        if(!this._priorUp && ("ArrowUp" in keys) && (this._numJumps > 0)) {
            this._vy = -5 / 1000 * timeStep;
            this._numJumps--;
            anim = "jump";
        }
        this._priorUp = "ArrowUp" in keys;
        
        if(this._sprite.getAnimation() != "jump") this._sprite.setAnimation(anim);
                
        this._vx += this._ax * timeStep;
        this._vx *= this._fric_fac;
        this._vy += this._ay * timeStep;
        this._vy *= this._fric_fac;
        
        this.x += this._vx * timeStep;
        this.y += this._vy * timeStep;
        
        if((this.y + this._inset[3]) >= (gameState.level.numChunks[1] * gameState.level.chunkSize)) return true;
                
        this._sprite.update(timeStep);
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [xi, yi, wi, hi] = this._inset;
        let [inx, iny] = [
            (this.x * this._blockSize) - (xi * this._blockSize), 
            (this.y * this._blockSize) - (yi * this._blockSize)
        ];
        let [cx, cy, cw, ch] = camera.transformBox([inx, iny, this._blockSize, this._blockSize]);
        
        if((Math.floor(this._waitTime / 50) % 2) == 0) this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollisions(obj, side) {
        if(side == "bottom") {
            this._numJumps = 2;
            if(this._sprite.getAnimation() == "jump") this._sprite.setAnimation("stand");
        }
        else if(obj instanceof Enemy && this._waitTime <= 0) {
            this._hp -= 2;
            this._waitTime = 1000;
        }
    }
    
    getHitBox() {
        let [xi, yi, wi, hi] = this._inset;
        return [this.x, this.y, wi, hi];
    }
}


class Enemy extends GameCollisionObject {
    constructor(x, y, blockSize, sprites) {
        super(x, y, blockSize, sprites);
        this._sprite = sprites.enemySprite.buildSprite();
        this._sprite.setAnimation("run");
        this._vx = 0;
        this._vy = 0;
        this._ax = 0;
        this._ay = 0.09 / 1000;
        this._fric_fac = 0.95;
        this._inset = [8 / 32, 2 / 32, 16 / 32, 27 / 32];
        
        this._hp = 5;
        
        this._movable = true;
    }
    
    update(timeStep, gameState) {
        if(this._hp <= 0) return true;
        
        this._sprite.update(timeStep);
        let [px, py] = gameState.getPlayer().getLocation();
        
        this._ax = 0.03 / 1000 * Math.sign(px - this.x);
        
        this._vx += this._ax * timeStep;
        this._vx *= this._fric_fac;
        this._vy += this._ay * timeStep;
        this._vy *= this._fric_fac;
        
        this.x += this._vx * timeStep;
        this.y += this._vy * timeStep;
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [xi, yi, wi, hi] = this._inset;
        let [inx, iny] = [
            (this.x * this._blockSize) - (xi * this._blockSize), 
            (this.y * this._blockSize) - (yi * this._blockSize)
        ];
        let [cx, cy, cw, ch] = camera.transformBox([inx, iny, this._blockSize, this._blockSize]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollisions(obj, side) {
        if(obj instanceof Player && side == "top") {
            this._hp = 0;
        }
        else if(obj instanceof Player && side != "bottom") {
            let d = (side == "left")? 1: -1;
            this._vx += d * 0.01; 
        }
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    getHitBox() {
        let [xi, yi, wi, hi] = this._inset;
        return [this.x, this.y, wi, hi];
    }
}

function draw(canvas, painter, gameState) {
    // Clear the canvas...
    painter.fillStyle = "white"
    painter.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw our single block...
    gameState.block.draw(gameState.canvas, gameState.painter, gameState.camera);
}

// This function will get called over and over...
function gameLoop(timeStep, gameState) {
    update(timeStep, gameState);
    draw(gameState.canvas, gameState.painter, gameState);
}

let gameState = {
    "block": new GameBlock(0, 0, 32),
    "cameraMoveSpeed": 5
}

let levelData = {
    sprites: {
        playerSprite: {
            image: "images/player.png",
            animations: {
                "stand": {
                    "frames": [0],
                },
                "run": {
                    "frames": [0, 1, 2, 3],
                    "speed": 100
                },
                "jump": {
                    "frames": [0, 4, 5],
                    "speed": 150,
                    "cycles": 1
                }
            }
        },
        enemySprite: {
            image: "images/enemy.png",
            animations: {
                "stand": {
                    "frames": [0],
                },
                "run": {
                    "frames": [0, 1, 2, 3],
                    "speed": 100
                },
                "jump": {
                    "frames": [0, 4, 5, 5, 4],
                    "speed": 150,
                    "cycles": 1
                }
            }
        }
    }
}

element.makeGame("testdata/test_level.json", [GameBlock], [Enemy], levelData, Player);
