%%javascript
// Game code goes here....

class LogBlock extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.logSprite.buildSprite();
        this._collisionSides = {"top": true};
    }
    
    update(timeStep, gameState) {}
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [cx, cy, cw, ch] = camera.transformBox([this.x, this.y - 3/32, 1, 1]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
}

class GameBlock extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.sandSprite.buildSprite();
        this._sprite.setAnimation("middle");
    }
    
    update(timeStep, gameState) {
        // Do we do anything in update?
        // No, because blocks don't move.
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [cx, cy, cw, ch] = camera.transformBox([this.x, this.y, 1, 1]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
}

class GameBlock2 extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.sandSprite.buildSprite();
        this._sprite.setAnimation("top");
    }
    
    update(timeStep, gameState) {
        // Do we do anything in update?
        // No, because blocks don't move.
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [cx, cy, cw, ch] = camera.transformBox([this.x, this.y - (3 / 32), 1, 35 / 32]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    getZOrder() {
        return 2;
    }
}

class Tree extends GameObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.treeSprite.buildSprite();
        this._numBlocks = 4;
        this._digIn = 4 / 32;
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let scale = this._numBlocks;
        let [cx, cy, cw, ch] = camera.transformBox([
            this.x, this.y, scale * (this._sprite.width / this._sprite.height), scale + this._digIn
        ]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    getHitBoxes() {
        return [[this.x, this.y, 5, 4]];
    }
    
    getZOrder() {
        return -1
    }
}

class Grass extends GameObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.grassSprite.buildSprite();
    }
    
    update(timeStep, gameState) {
        // Do we do anything in update?
        // No, because blocks don't move.
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [cx, cy, cw, ch] = camera.transformBox([this.x, this.y, 1, 35/32]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
}

class Player extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.playerSprite.buildSprite();
        this._sprite.setAnimation("stand");
        this._inset = [4 / 32, 4 / 32, 28 / 32, 24 / 32];
        this._vx = 0;
        this._vy = 0;
        this._pvx = 0;
        this._pvy = 0;
        this._ax = 0;
        this._ay = 0.085 / 1000;
        this._priorUp = false;
        this._numJumps = Infinity;
        this._fric_facx = 0.915;
        this._fric_facy = 0.999;
        this._waitTime = 0;
        
        this._collisionSides = [
            {"top": true, "left": true, "right": true, "bottom": true},
            {"top": true, "left": true, "right": true}
        ];
        
        this._hp = 5;
        
        this._movable = true;
        this._in_water = false;
    }
    
    update(timeStep, gameState) {
        this._waitTime = Math.max(0, this._waitTime - timeStep);
        
        if(this._hp <= 0) {
            this._hp = 5;
            this._waitTime = 0;
            gameState.exitZone(gameState.zoneName);
        }
        
        let keys = gameState.keysPressed;
        
        let anim = "stand"
        
        this._ax = 0;
        if("ArrowLeft" in keys) {
            this._ax -= 0.1 / 1000;
            anim = "run";
            this._sprite.setHorizontalFlip(true);
        }
        if("ArrowRight" in keys) {
            this._ax += 0.1 / 1000;
            anim = "run";
            this._sprite.setHorizontalFlip(false);
        }
        if(!this._priorUp && ("ArrowUp" in keys) && (this._numJumps > 0)) {
            this._vy = -22 / 1000;
            this._numJumps--;
            anim = "jump";
        }
        this._priorUp = "ArrowUp" in keys;
        
        if(this._sprite.getAnimation() != "jump") this._sprite.setAnimation(anim);
        if(this._in_water) this._sprite.setAnimation("water");
        this._in_water = false;
                
        this._vx += this._ax * timeStep;
        this._vx *= this._fric_facx;
        this._vy += this._ay * timeStep;
        this._vy *= this._fric_facy;
        
        this._pvx = this._vx;
        this._pvy = this._vy;
        
        this.x += this._vx * timeStep;
        this.y += this._vy * timeStep;
        
        let [__x, __y, w, h] = gameState.getLevelBounds();
        if((this.y + this._inset[3]) >= h) gameState.exitZone(gameState.zoneName);
        
        this._sprite.update(timeStep);
        this._fric_facy = 0.9999;
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [xi, yi, wi, hi] = this._inset;
        let [inx, iny] = [
            this.x - xi, 
            this.y - yi
        ];
        let [cx, cy, cw, ch] = camera.transformBox([inx, iny, 42 / 32, 1]);
        
        if((Math.floor(this._waitTime / 50) % 2) == 0) this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollision(obj, side) {
        if(obj instanceof Water || obj instanceof WaterTop) {
            this._in_water = true;
            return;
        }

        if(side == "inside") return;
        if(side == "bottom") {
            this._numJumps = 2;
            if(this._sprite.getAnimation() == "jump") this._sprite.setAnimation("stand");
            if(obj instanceof Enemy) this._vy = -this._vy;
            else this._vy = 0;
        }
        else if(obj instanceof Enemy && this._waitTime <= 0) {
            this._hp -= 2;
            this._waitTime = 1000;
        }
        
        if(side == "left" || side == "right") {
            if(!(obj instanceof Ball)) this._vx = 0;
        }
    }
    
    getHitBoxes() {
        let [xi, yi, wi, hi] = this._inset;
        let box2 = (this._sprite.isHorizontallyFlipped())? [this.x, this.y, 8 / 32, 9 / 32]: [this.x + wi - 8 / 32, this.y, 8 / 32, 9 / 32];
        
        return [
            [this.x, this.y + 9 / 32, wi, hi - 9 / 32],
            box2
        ];
    }
}


class Enemy extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this.__ss = assets.sprites;
        this._sprite = assets.sprites.enemySprite.buildSprite();
        this._sprite.setAnimation("stand");
        this._vx = 0;
        this._vy = 0;
        this._ax = 0;
        this._ay = 0.09 / 1000;
        this._fric_fac = 0.95;
        this._inset = [10 / 32, 0 / 32, 73 / 32, 16 / 32];
        this._blocksBelow = [false, false];
        
        this._hp = 5;
        
        this._movable = true;
        this._gState = null;
    }
    
    update(timeStep, gameState) {
        if(this._hp <= 0) return true;
        
        let minPX = null;
        let minDist = Infinity;
        
        for(let player of gameState.getPlayers()) {
            let [px, py] = player.getLocation();
            let dist = Math.sqrt((px - this.x) * (px - this.x) + (py - this.y) * (py - this.y));
            if(dist < minDist) {
                minPX = px;
                minDist = dist;
            }
        }
        
        this._ax = (minPX != null && minDist < 9)? 0.03 / 1000 * Math.sign(minPX - this.x): 0;
        
        if(this._ax != 0) {
            this._sprite.setHorizontalFlip(this._ax > 0);
            this._sprite.setAnimation("run");
        }
        else this._sprite.setAnimation("stand");
        
        this.updateBlockInfo(timeStep, gameState);
        if(!this._blocksBelow[(this._ax < 0)? 0: 1]) this._ax *= -1;
        
        this._vx += this._ax * timeStep;
        this._vx *= this._fric_fac;
                
        this._vy += this._ay * timeStep;
        this._vy *= this._fric_fac;
        
        this.x += this._vx * timeStep;
        this.y += this._vy * timeStep;
        
        this._sprite.update(timeStep);
    }
    
    updateBlockInfo(timeStep, gameState) {
        this._blocksBelow[0] = gameState.getBlocksAround(this.x, this.y + this._inset[3] / 2)[1][2] != null;
        this._blocksBelow[1] = gameState.getBlocksAround(this.x + this._inset[2], this.y + this._inset[3] / 2)[1][2] != null;
    }
    
    draw(canvas, painter, camera) {
        // Implement this:
        let [xi, yi, wi, hi] = this._inset;
        let [inx, iny] = [
            this.x - xi, 
            this.y - yi
        ];
        let [cx, cy, cw, ch] = camera.transformBox([inx, iny, 96 / 32, 24 / 32]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollision(obj, side) {
        if(obj instanceof Water || obj instanceof WaterTop) return;
        if(side == "bottom") this._vy = 0;
        
        if((obj instanceof Player) && side == "top") {
            this._hp = 0;
        }
        else if((obj instanceof Player || obj instanceof Enemy) && side != "bottom") {
            let d = (side == "left")? 1: -1;
            this._vx += d * 0.01; 
        }
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    getHitBoxes() {
        let [xi, yi, wi, hi] = this._inset;
        return [[this.x, this.y, wi, hi]];
    }
}

class Ball extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.beachBallSprite.buildSprite();
        this._sprite.setAnimation("still");
        this._vx = 0;
        this._vy = 0;
        this._ay = 0.04 / 1000;
        this._fric_fac = 0.95;
        this._inset = [10 / 32, 0 / 32, 73 / 32, 16 / 32];
        this._blocksBelow = [false, false];
        
        this._hp = 5;
        
        this._movable = true;
    }
    
    update(timeStep, gameState) {
        this._vx *= this._fric_fac;
        this._vy += this._ay * timeStep;
        this._vy *= this._fric_fac;
        
        this._pvx = this._vx;
        this._pvy = this._vy;
        
        this.x += this._vx * timeStep;
        this.y += this._vy * timeStep;
        
        if(Math.abs(this._vx) > 0.0001) this._sprite.setAnimation("spin");
        else this._sprite.setAnimation("still");
        this._sprite.setHorizontalFlip(this._vx < 0);
        this._sprite.update(timeStep);
    }
    
    draw(canvas, painter, camera) {
        let [cx, cy, cw, ch] = camera.transformBox(this.getBoundingBox());
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollision(obj, side) {
        if(obj instanceof Water || obj instanceof WaterTop) return;
        if(side == "inside") return;
        if(side == "top" || side == "bottom") {
            if(obj instanceof Ball) {
                this._vy = ((side == "top")? 1: -1) * Math.abs(obj._vy) * 0.8;
            }
            else {
                this._vy = ((side == "top")? 1: -1) * Math.abs(this._vy) + (obj._vy ?? 0) * 0.8;
            }
        }
        else {
            let vx = this._vx;
            
            if(obj instanceof Ball) {
                this._vx = ((side == "left")? 1: -1) * Math.abs(obj._vx) * 0.8;
                this._vy -= 0.02;
            }
            else {
                this._vx = ((side == "left")? 1: -1) * Math.abs(this._vx + 0.01) + (obj._vx ?? 0) * 0.8;
                this._vy -= 0.02;
            }
        }
    }
}

class WaterTop extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.water.buildSprite();
        this._sprite.setAnimation("top");
        this._weight = 2 / 1000;
    }
    
    update(timeStep, gameState) {
        this._sprite.update(timeStep);
    }
    
    draw(canvas, painter, camera) {
        let [cx, cy, cw, ch] = camera.transformBox([this.x, this.y, 1, 1]);
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollision(obj, side) {
        if(obj instanceof Player) {
            obj._fric_facy = 0.95;
            obj._numJumps = 2;
        }
        // Compute the boyant force... and add it onto the objects velocity...
        let [wx, wy, ww, wh] = this.getBoundingBox();
        let [ox, oy, ow, oh] = obj.getBoundingBox();

        let yIn = Math.min(Math.abs((wy + wh) - oy), Math.abs((oy + oh) - wy));
        let xIn = Math.min(Math.abs((wx + ww) - ox), Math.abs((ox + ow) - wx))
        obj._vy -= ((xIn * yIn) / (ww * wh)) * this._weight;
    }
    
    isSolid() {
        return false;
    }
    
    getHitBoxes() {
        return [[this.x, this.y + 0.25, 1, 0.75]];
    }
    
    getZOrder() {
        return 1;
    }
}

class Water extends GameCollisionObject {
    constructor(x, y, assets) {
        super(x, y, assets);
        this._sprite = assets.sprites.water.buildSprite();
        this._sprite.setAnimation("below");
        this._weight = 2 / 1000;
    }
    
    update(timeStep, gameState) {
        this._sprite.update(timeStep);
    }
    
    draw(canvas, painter, camera) {
        let [cx, cy, cw, ch] = camera.transformBox(this.getBoundingBox());
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    drawPreview(canvas, painter, box) {
        let [cx, cy, cw, ch] = box;        
        this._sprite.draw(painter, cx, cy, cw, ch);
    }
    
    handleCollision(obj, side) {
        if(obj instanceof Player) {
            obj._fric_facy = 0.95;
            obj._numJumps = 2;
        }
        // Compute the boyant force... and add it onto the objects velocity...
        let [wx, wy, ww, wh] = this.getBoundingBox();
        let [ox, oy, ow, oh] = obj.getBoundingBox();
        
        let yIn = Math.min(Math.abs((wy + wh) - oy), Math.abs((oy + oh) - wy));
        let xIn = Math.min(Math.abs((wx + ww) - ox), Math.abs((ox + ow) - wx))
        obj._vy -= ((xIn * yIn) / (ww * wh)) * this._weight;
    }
    
    isSolid() {
        return false;
    }
    
    getZOrder() {
        return 1;
    }
}

let gameInfo = {
    objects: {
        blocks: [GameBlock, GameBlock2, Tree, Grass, LogBlock, WaterTop, Water],
        entities: [Enemy, Ball],
        players: [Player]
    },
    assets: {
        sprites: {
            playerSprite: {
                image: "images/seagull2.png",
                width: 42,
                animations: {
                    "stand": {
                        "frames": [0],
                    },
                    "run": {
                        "frames": range(21),
                        "speed": 10
                    },
                    "water": {
                        "frames": [21]
                    },
                    "jump": {
                        "frames": [0, 4, 5],
                        "speed": 150,
                        "cycles": 1
                    }
                }
            },
            enemySprite: {
                image: "images/croc.png",
                width: 96,
                animations: {
                    "stand": {
                        "frames": [4, 5],
                        "speed": 500
                    },
                    "run": {
                        "frames": [0, 1, 2, 3],
                        "speed": 100
                    }
                }
            },
            sandSprite: {
                image: "images/sand.png",
                animations: {
                    "top": {
                        "frames": [0]
                    },
                    "middle": {
                        "frames": [1]
                    }
                }
            },
            backgroundSprite: {
                image: "images/background2.png",
                width: 250
            },
            treeSprite: {
                image: "images/tree.png",
                width: 60
            },
            grassSprite: {
                image: "images/grass.png",
                width: 20
            },
            logSprite: {
                image: "images/log.png"
            },
            beachBallSprite: {
                image: "images/beachball.png",
                animations: {
                    "still": {
                        "frames": [0]
                    },
                    "spin": {
                        "speed": 100
                    }
                }
            },
            water: {
                image: "images/water.png",
                animations: {
                    "below": {
                        "frames": [0],
                        "speed": 50
                    },
                    "top": {
                        "frames": range(1, 17),
                        "speed": 50
                    }
                }
            }
        },
    },
    zones: {
        test: {
            zoneData: "testdata/test_level.json",
            preDraw: function(canvas, painter, gameState) {
                if(gameState.background == null) gameState.background = gameState.assets.sprites.backgroundSprite.buildSprite();        

                let bk = gameState.background;
                let bgRatio = (bk.width / bk.height);
                let cRatio = (canvas.width / canvas.height);

                let {width, height} = canvas;

                width = (bgRatio < cRatio)? width: height * bgRatio;
                height = (bgRatio < cRatio)? width / bgRatio: height;
                let centerX = canvas.width / 2;
                let centerY = canvas.height / 2;

                gameState.background.draw(painter, centerX - width / 2, centerY - height / 2, width, height);
            }
        },
    }
};

element.makeGame(gameInfo, "test");
